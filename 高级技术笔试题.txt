nginx
	1、请解释一下什么是Nginx?
		Nginx是一个高性能的HTTP和反向代理服务。
	2、请列举Nginx的一些特性。
		在连接高并发的情况下，Nginx是Apache服务不错的替代品。Nginx是美国做虚拟主机生意老板们选择的软件平台之一。
		nginx采用io多路复用epoll模型，一种io空闲主动上报机制，一个线程并行处理io请求，没有堵塞。不会因为某一路请求的io堵塞导致后面在请求无法执行
		nginx轻量级，功能模块少，代码模块化。
	3、请列举Nginx和Apache 之间的不同点。
		apache httpd：稳定、对动态请求处理强，但同时高并发时性能较弱，耗费资源多。
		nginx：高并发处理强、擅长处理静态请求、反向代理、负载均衡、耗费资源少。
	4、请解释Nginx如何处理HTTP请求。
		1.首先我们在nginx的配置文件中配置了
			server {
				listen port;
				server_name address;
				...
			}
		2.http发送请求到nginx里面，nginx并收到请求
			nginx会根据发送过来的htpp请求头里的host地址值，来判断具体是哪一个server{}来执行。
				1.如果请求头里面没有host值，或者host字段里的值，和nginx配置文件里的server里的server_name都不匹配，则使用第一个server来执行。
				2.如果请求头里的host字段值和Nginx配置文件里的某个server里的server_name相匹配了，则使用这个server来进行处理请求。
			重要结论：server_name对应的是http请求头里的host字段的值 	
		3.Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。
	5、在Nginx中，如何使用未定义的服务器名称来阻止处理请求?
		只需要将请求删除的服务器就可以定义为:
			server {
				listen 80;
				server_name "";
				return 444;
			}
	6、 使用“反向代理服务器”的优点是什么?
		方向代理服务器可以隐藏服务器的存在和特征，保护服务器。它充当与互联网和web服务器之间的中间层。
	7、请列举Nginx服务器的最佳用途。
		Nginx服务器的最佳用法是在网络上部署动态HTTP内容。还可以作为反向代理负载均衡；
	8、请解释Nginx服务器上的Master和Worker进程分别是什么?
		Master：读取及评估配置和维护
		Worker：处理请求
	9、请解释你如何通过不同于80的端口开启Nginx?
		为了通过一个不同的端口开启Nginx，必须进入/etc/Nginx/sites-enabled/，如果这是默认文件，必须打开名为“default”的文件，编辑文件，并放置你想要的端口
		Like server { listen 81; }
	10、请解释是否有可能将Nginx的错误替换为502错误、503?
		502=网关错误
		503=服务器超载
		有可能，但是必须确保fastcgi_intercept_errors被设置为ON，并使用错误页面指令。
		Location / {
			fastcgi_pass 127.0.01:9001;
			fastcgi_intercept_errors on;
			error_page 502 =503/error_page.html;
			#…
		}
	11、在Nginx中，解释如何在URL中保留双斜线?
		要在URL中保留双斜杠，就必须使用merge_slasshes_off;
		语法：merge_slashes [on/off]
		默认值:merge_slashes on
		环境:http, server
	12、请解释ngx_http_upstream_module的作用是什么?
		ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和scgi传递指令来引用的服务器组。
	13、请解释什么是C10K问题?
		C10K问题是指无法同时处理大量客户端(10,000)的网络套接字
	14、请陈述stub_status和sub_filter指令的作用是什么?
		stub_status指令：该指令用于了解Nginx当前状态的当前状态，如当前的活动连接，接收和处理当前读写等连接的总数
		sub_filter指令：它用于搜索和替换响应中的内容，兵快u埃苏修复陈旧的数据
	15、解释Nginx是否支持将请求压缩到上游?
		可以通过使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持 gzip 编码方法的客户机或服务器使用内容编码：gzip 来解压压缩响应。
	16、解释如何在Nginx中获得当前的时间?
		必须使用SSI模块、$date_gmt和$date_local变量。
		Proxy_set_header THE-TIME $date_gmt;
	17  为什么要做动、静分离
		概念：
			让动态的只走动态的服务器
			让静态的只走静态的服务器
		在服务器层面上：
			为动静态服务器准备专门适应调优的专业服务器，分担服务器压力，选择最优的处理技术
		程序层面上：
			让一次数据没有变化、查询没有变化修改的页面直接静态化，一段时间不去修改等的，直接静态化。设置一些缓存等，提高效率
		
		提升资源的利用率、用户体验更快、效率更高。同时也会带来成本的增加。
redis 
	1 讲解一下Redis的持久化机制
		Redis有两种持久化方案：RDB AOF
		RDB是一种快照持久化全量备份，备份的是内存数据二进制序列化格式。
		AOF是持久化增量备份，记录的是内存数据修改的执行记录文本。所有AOF持久化生成的日志会随着时间运行边变长而变得越来越臃肿，每次重启Redis都需要加载AOF日志进行指令重放，所以需要定期重写AOF日志进行瘦身操作。

		快照持久化（RDB）
		RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，子进程负责将数据集写入临时文件由于os的写时复制机制父子进程会共享相同的物理界面，当父进程处理写请求时os会为父进程创建页面副本，所以紫禁城地址空间的数据实际上就是一个快照，写入成功后，再替换之前的文件，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。Redis使用操作系统的多进程COW机制实现RDB持久化。

		优点：

		只有一个备份文件dump.rdb，方便持久化备份；
		容灾性好，一个文件可以保存到其他存储介质；
		性能最大化，fork出子进程来完成写操作，让主进程继续处理命令，所以是IO最大化（使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) ；
		如果数据集偏大，RDB的启动效率会比AOF更高。
		缺点：

		数据安全性低。
		如果当数据集较大时，可能会导致整个服务器停止服务。
		RDB持久化是 Redis 默认采用的持久化方式，可以在 redis.conf 配置文件中进行配置Redis在N秒内如果超过M个key被修改就自动做快照：

		save 900 1：在15分钟内，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
		save 300 10：在5分钟内，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
		save 60 10000：在1分钟之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
		AOF持久化

		AOF持久化是以日志的形式记录每一个增删操作，会将所有增删操作通过write函数追加到文件中。AOF的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启会通过执行文件中保存的写命令在内存中重建整个数据库的内容。与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。 默认情况下 Redis 没有开启 AOF持久化，可以通过设置 appendonly 参数开启：

		appendonly yes
		Redis通过fork出子进程，子进程根据内存中的快照，往临时文件中写入重建数据库状态的指令，父进程继续处理请求，当子进程将快照内容写入到临时文件中则发信号通知父进程将缓存中的写操作也写入到临时文件中，最后使用临时文件替代旧备份文件并进行重命名。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

		appendfsync always：每次有数据修改发生时都会写入AOF文件
		appendfsync everysec：每秒钟同步一次，将多个写命令同步到硬盘
		appendfsync no：让操作系统决定何时进行同步
		用户可以使用appendfsync everysec选项 ，让 Redis 每秒同步一次 AOF 文件，这样Redis性能几乎不会受到影响，而且这样即使出现宕机，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

		优点：

		数据安全性更高，AOF持久化可以配置appendfsync属性

		通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。

		AOF机制的rewrite模式。

		缺点：

		AOF文件比RDB文件大，且恢复速度慢；

		数据集大的时候，比RDB启动效率低。

		根据同步策略的不同，AOF在运行效率上往往会慢于RDB。

		对于Redis的两种持久化机制的选择，主要还是得针对特定的系统讨论，看是可以牺牲一定的性能使用AOF持久化换取缓存一致性，还是在增删操作频繁时关闭备份，等到Redis空闲手动save做RDB持久化备份。所以其实最佳方案应该是采用混合持久化方案，开启混合持久化后，AOF重写日志时会将RDB持久化的内容写到AOF文件开头，于是在Redis重启时，可以先加载RDB的内容，再对增量的AOF日志进行重放，提升Redis重启的效率。
	2 解释一下缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题以及解决方案
		缓存雪崩：
			当Redis服务器重启或大量缓存在同一时间到期，此时大量的流量会全部冲击到数据库上面，数据库可能会承受不住压力会宕机。
			解决方案：
				1.并发量不是很多的时候，使用最多的就是加锁排队
				2.随机均匀设置缓存失效时间，防止同一时间过期失效的太多。
				3.给每个缓存设置一个缓存标记，记录缓存的失效时间，如果缓存失效，则更新数据缓存。
					缓存标记：记录缓存数据是否过期，如果过期则通知线程后台去更新key的缓存
					缓存数据：他的过期时间比缓存标记时间延长1倍。比如缓存标记 5分钟，缓存数据就是10分钟，这样如果缓存标记过期，后台还可以返回实际缓存的数据，直至后台更新完缓存标记和缓存数据的时间。
		缓存穿透：
			当用户查询数据的时候数据库里面没有，那么缓存里面自然也不会有。这样就导致用户在查询的时候找不到，返回空。如果是用户还好，如果是黑客故意搞破坏，这样后果就会很严重了！Redis和数据库都会造成很大的压力。
			解决方案：
				1.采用缓存空值的方案，当从数据库查询的对象为空的时候，也存放到缓存，但是时间设置短一些，这样就不会继续访问数据库了。
				2.布隆过滤器
		缓存预热：
			将相关系统需要缓存的数据直接先缓存到缓存系统中，加快用户的访问速度。
			解决方案：
				1.直接写个缓存刷新页面，上线时候手工操作以下
				2.定时器自动刷新
				3.数据量不大的时候，可以在项目启动的时候自动加载
		缓存更新：
			缓存更新是一种机制，以保证key的数据是实时有效的。，以及及时更新数据
			解决方案：
				1.定时清理过期的缓存
				2.当有用户请求过来的时候，再判断这个请求所用到的key是否失效过期，过期的话就去底层更新并得到数据。
		缓存降级：
			当访问量剧增、服务出现问题，响应慢或者不响应非核心服务影响到核心流程的性能时候，仍然需要服务还是可用的，即使是有损服务。
			系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。
			解决办法：
				在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些誓死保卫，哪些可以降级；比如可以参考日志级别设置预案；
				1.一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级。
				2.警告：有些服务再一段时间内成功率波动，可以自动降级或者人工降级并发出警告
				3.错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级
				4.严重错误：比如因为特殊原因数据错了，此时需要紧急人工降级。
	3 热点数据和冷数据是什么
		热点数据就是被查询到的次数多、使用的非常发的多，价值大
		冷数据 使用的查询的少，经常被修改次数高
	4 Memcache与Redis的区别都有哪些？
		1.存储方式Memcache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部分存在硬盘上，redis可以持久化数据更安全
		2.Memcache仅仅支持简单的字符串，redis作为其替代者，支持更为丰富的数据类型，提供list，set，zset，hash等数据结构存储
		3.value值大小不同：Redis最大可以打到512M；Memcache只有1mb
		4.Redis的速度比Memcache快很多。
		5.Redis支持数据的备份，即Master-slave模式的数据备份
		6.使用底层模型不同，他们之间底层实现方式以及客户端通信之间应用协议不同。Redis直接自己构建了VM机制，因为一般系统调用系统函数的话，会浪费一定时间去移动和请求。
	5单线程的redis为什么这么快
		1.纯内存操作
		2.的那线程操还，避免了频繁的上下文切换
		3.采用了非阻塞I/O多路复用机制模型。
	6 redis的数据类型有哪些，以及每种数据类型的使用场景
		一共5种
		1.String	
			最常见set/get操作，value可以是string类型也可以是数字，做一些基础数据的存储
		2.hash
			这里value存放的是结构化对象，比较方便的就是操作其中某个字段。key和value的形式。
		3.list
			list数据机构可以做简单的消息队列。完成排队，先进先出
		4.set
			set存放一堆不重复的集合。
		5.sorted set
			sorted set多了一个权重参数，集合种的元素能够按照score进行排列。可以作为排行榜应用，取TOP N操作。
	7 Redis 内部结构是怎么样的
		dict 本质上是为了解决算法中查找问题（Searching)是一个用于维护key和value映射关系的数据结构，域很多语言中的Map或dictionary类似。被之上是为了解决算法种的查找问题（Searching）
		sds sds就等同于char * 它可以存储任意二进制数据，它有个长度字段
		skiplist 跳跃表，跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现更优化。
		quciklist
		ziplist 压缩表
	8 redis的过期策略以及内存淘汰机制是怎样的
		Redis采用的是定期删除+惰性删除策略
		定期删除：
			Redis默认采用每100ms检查 是否有过期的key，有过期的key及时删除。但并不是检测所有的key，而是随机检测一部分。因此只有定期删除策略，会导致很多key没有时间删除
		惰性删除：
			再获取使用某个Key的时候，redis会检测以下，如果这个key设置了过期时间那么是否过期了，如果过期了就直接删除。
		采用定期删除+惰性删除也会产生其它问题，如果定期删除没有删除key，同时也没有去请求这个key，也就说明惰性删除没有使用。这样redis的内存会越来越高。那么就应该采用内存淘汰机制了。
		再redis.conf种有这个一行就是配置内存淘汰机制的
			maxmemory-policy volatile-lru
		该配置就是配置内存淘汰策略的。
		volatile-lru：从已设置过期时间的数据集(server.db[i].expires)中挑选最近使用最少的数据淘汰
		volatile-ttl：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
		volatile-random：从已设置过期时间的数据集(server.db[i].expires)中随机淘汰
		allkeys-lru：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰
		allkeys-random：从数据集(server.db[i].dict)中任意数据随机淘汰
		no-enviction：禁止驱逐数据，这也是默认策略意思是当内存不足以容纳新的数据时候，新写入数据就会保存，请求可以继续运行，采用no-enviction策略可以保证数据不被丢失。
		如果没有设置expire的key，不满足先决条件(prerequisites);那么volatile-lru,volatile-ttl,volatile-random策略行为和noeviction基本上一直。
	9 Redis 为什么是单线程的?
		因为Redis是基于内存操作，CPU不是Redis的瓶颈，Redis的瓶颈最优可能是及其内存的大小和网络带宽。
		既然单线程容易实现，而且cpu不会称为瓶颈，那么采用单线程会比多线程简单许多问题出现的少很多。
		Redis利用队列技术将并发访问变为串行访问。
		1）绝大部分请求时纯粹的内存中 非常快速
		2）采用单线程避免了不必要的上下文切换和竞争条件
		3）非阻塞IO优点
	10 Redis 集群方案应该怎么做？都有哪些方案？
		1.Redis cluster 3.0自带的集群，特点在于它的分布式算法不是一致性hash，而是hash槽的概念。以及自身支持节点设置从节点等
		2.codis 目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持再节点数量改变的情况下，旧节点数据可恢复到新节点hash节点。
	11 有没有尝试进行多机redis 的部署？如何保证数据一致的？
		主从复制，读写分离。
		一类时主数据库master 一类是从数据库slave，主数据库可以进行读写操作，当发生写操作的时候子哦对那个将数据同步到从数据库，而从数据库一般只是只读的，并接受主数据库同步过来的数据。
		一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。
	12 对于大量的请求怎么样处理
		redis是一个单线程程序，也就是说同一时刻只能处理一个客户端的请求。
		redis是通过IO多路复用来处理客户端请求的
	13 Redis 常见性能问题和解决方案？
		1.Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
		2.如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
		3.为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。
		4.尽量避免在压力很大的库上增加从库。
		5.主从复制不要用图状结构，用单项链表接哦古更为稳定。即Master<Slave1<Slave2<Slave3
	14 说说Redis的事务
		Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH四个源语实现的
		Redis会将一个事务中的所有命令序列化，然后按顺序执行
		1.redis不支持回滚，Redis再事务失败时候不能进行ui滚，而是继续执行余下命令，所以Redis的内部可以保持简单快速
		2.如果哪一个事务中的命令出现错误，那么所有的命令都不会执行
		3.如果一个事务中出现运行错误，那么正确的执行会被执行。
		
		MULTI：用于开启一个事务，他总是返回OK。MULTI执行之后，客户端继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
		EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时候，返回空值 nil。
		DISCARD：客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。
		WATCH：为Redis事务提供 check-and-set （CAS――行为。可以监控一个或多个键，一旦其中一个键被修改或删除，之后的事务不会被执行，监控一直持续到EXEC命令。
	15 说说Redis如何实现分布式锁
		Redis为单进程单线程模式，采用队列模式将并发访问编程串行访问，且多客户端对Redis的连接并不存在金正关系Redis中可以使用SETNX命令实现分布式锁。
		将key的值设置为value，当且当key不存在。若给定的key已经存在，则SETNX不做任何操作。 不存在返回1 存在返回0
			setnx local value 返回 1 key不存在
			setnx local value2 返回0 key存在
		解锁：使用del key命令就能释放锁
		解决死锁：
			1）通过Redis中的expire()给锁设定最大的持有时间，如果超过，则Redis来帮助我们释放锁
	
solr
	1 简单介绍一下solr
		Solr是基于Lucene的面向企业搜索的web应用。
		是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service 的API接口。用户可以通过http请求，向搜索引擎服务提交一定格式的xml文件，生成索引；也可以根据http get操作查找请求，得到xml/json数据格式返回。
		又是一款优秀的全文检索引擎。
	2 同类型技术有哪些?对比一下
		Elasticsearch 是分布式的。不需要其它组件，分发是实时的。完全支持Luncene的接近实时搜索。
		Solr：有一个更大，更成熟的用户、开发和贡献社区  支持多种索引格式，更成熟稳定
	3 说说你使用solr的步骤
		环境以Linux来说，
			首先及其要安装jdk，然后安装solr，吧solr的jar包等放置到tomcat服务器上开始运行
			在我们真正使用solr的时候还需要配置它的索引库。
	4 说说schema.xml的作用,以及该配置文件中常用的标签,属性,及其作用
		schema.xml是用来定义索引数据中的域的，包括域名称，域类型，域是否索引，是否分词，是否存储等等。
		<field name="_version" type="long" indexed="true" stored="true" /> 定义域
			name：表示域的名称，是强制必须要有得属性
			type：域类型得名称，与fieldType元素的name属性值对应，是强制必须有的属性
			indexed：是否参与检索，true即表示需要对该域进行检索。默认法拉瑟
			stored：是否将field域中的内容存储到文本域，简单通俗的来说，就是你这一个field需不需要被当作查询结果返回。
			requred：表示这个域是否是必须要再document中存在，默认值为false，如果此配置设为true，则你的document中必须要添加此域，否则你创建索引时候会抛出异常
		<fieldType name="string" class="solr.StrField" sortMissingLast="true" /> 定义域类型
			name：域类型的名称，作为域类型标识符存在，再定义域（Field）时使用的类型（fieldType）属性就是域类型的名称
			class：域类型的数据类型，该属性指向的时solr中以定义的类型，或者是用户定义的类型，域类型中的数据会被初始化成class执行类类的对象
			sortMissingFirst/sortMissingLast：控制当排序域的值不存在时该文档（Document）所在队列的位置。true是队头/队尾
		<copyField source="item_titile" dest="item_keywords">：复制域。可实现更新与查询分离。
			source：源域
			dset：目标域
	5 什么是倒排索引？
		倒排索引又称为反向索引。
		对数据进行分析，抽取出数据中的词条，以词条作为key，对应数据的存储位置作为value，实现索引的存储。这种索引称为到排索引。
	6 中文分词器IK Analyzer的作用什么是？
		默认solr不支持中文的分词，IK Analyzer可以支持中文分词。
	7 介绍一下solr的管理界面
		Dashboard 仪表盘 可以看到solr的基础信息比如运行时间版本 系统内存 虚拟机内存等。
		Logging 日志
		Core Admin 对core进行管理
		Dataimport 导入数据
		Documents 索引文档，相关的查询增加修改删除操作等
		Query 查询页面 功能最核心的查询数据页面。
	
activemq
	1 介绍一下activemq
		ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是规范的JMS Provider实现，尽管JMS规范出台很久，但是仍有很重要的地位。
	2 介绍一下activemq的几种通信方式
		点对点模型（Point To Point） 生产者发送一条消息到queue，只有一个消费者能接收到
		发布订阅模型（Publish/Subscribe) 发布者发送到topic的消息，只有订阅了topic的订阅者才会接收到消息
	3 如何解决消息重复问题
		造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是不解决，转而绕过这个问题。
		那么解决的办法就是：
			1.消费端处理消息的业务逻辑保持幂等性
			2.保证每条消息都有唯一编号且保证消息处理成功与去重表的id作比较。
	4 activemq如果数据提交不成功怎么办(消息丢失)
		https://www.cnblogs.com/-zhuang/articles/10596559.html
		如果是点对点模式，此消息会默认保存再服务器端，直至客户端接收到消息后将其消费掉，所以此消息不会丢失
		如果是发布订阅模式，默认只通知一次，没有接收到此消息也就没有了。
			1.如果要求消息必须送达，不可以丢失的话就必须配置持久化订阅
			2.每个订阅端定义一个id，在订阅时向ActiveMQ注册，发布消息和接收消息需要配置发送模式为持久化。
			  此时如果客户端接收步到消息的话，消息会持久化在服务端，知道客户端接收到位置。
	5 持久化消息非常慢怎么办?
		需要知道的是，发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存或远程数据库，然后试图将消息发送给接收者，如果接收者成功接收，那么将数据从存储中删除。
		那么在这个环节写入数据，可能是网络原因造成也有可能是存储系统速度过慢等造成。
	6 ActiveMQ服务器宕机怎么办
		可以设置ActiveMQ集群
		ActiveMQ提供了一种叫做失效转移也叫做故障转移failover的策略。试下转移提供了在传输层面上重新连接到其它任何传输器的功能。使用很简单只需要在uri中配置就ok
		如果ActiveMQ客户端发现uri1失效，就会在uri列表中随机连接其它的消息服务器重连，以保证继续工作。
		如果ActiveMQ集群全部宕机，ActiveMQ提供了消息传输监听(transportListener),可以对ActiveMQConnectionFactory添加一个ActiveMQ的消息传输监听，该监听实现了ActiveMQ的TransportListener接口。
		当发现服务器无法连接时，就采取响应措施，如把消息存储在本地，当服务器恢复的时候在进行发送。
	7 说说ActiveMQ中的常用API
		ConnectionFactory 链接工厂，用于创建链接的工厂类型
		Connection 链接，用于建立访问ActiveMQ连接的类型，由链接工厂创建
		Session 会话，一次持久有效的状态的访问，由链接创建
		Destination & Queue 目的地，用故意描述本次ActiveMQ的消息访问的目的地，即ActiveMQ服务中的具体队列，由会话创建
		MessageProduct 消息生成这
		MessageConsumer 消息消费者
		Message 消息，通过消息生成这向ActiveMQ服务发送消息时使用的数据载体对象或消息消费者从ActiveMQ服务中获取消息时使用的数据载体对象。
jsonp
	1 解释一下什么是同源策略?
		指浏览器对不同源的脚本或者文本的访问方式进行了限制。
		同源指的是：协议、域名、端口都相同，有一个不同都不可以。
	2 说说实现跨域访问的几种解决方案
		1.使用jsonp解决网站跨域
		2.使用HttpClient内部转发
		3.使用设置响应头允许跨域
		4.基于Nginx搭建API接口网关
		5.使用Zull搭建微服务API接口网关
	3 编码题,使用jsonp解决跨域访问
		@RequestMapping("/a")
		public Map<String, Object> a(HttpServletResponse response) {
			// 设置响应头
			response.setHeader("Access-Control-Allow-Origin", "*");
			return new HashMap();
		}
httpclient
	1 编码题,使用httpClient的API发送请求,接受数据
		@RequestMapping("/a"
		@ResponseBody
		public Object forward() {
			JSONObject reuslt = HttpClientUtils.httpGet("http://baidu.com/a");
			return result;
		}
	
mycat
	1、单表数据达到多少的时候会影响数据库的查询性能？为什么？
		广为流传的百度2000万条的时候mysql性能急剧下降，后来阿里巴巴的java开发手册中提出表行超过500万行或者表容量超过2GB，才推荐进行分库分表。
		事实上这个数值和实际记录的条数无关，而与Mysql的配置以及及其的硬件相关。
		因为Mysql为了提高性能，会将表的索引装载到内存中。InnoDB Buffer Size 足够的情况下， 其能够完全加载到内存中，查询不会由问题。但是，但单表数据达到某个量级上线时，导致内存无法存储其索引，
			使得之后的SQL查询会产生磁盘IO，从而导致性能下降。当然，这个还有具体的表结构设计有关，最终导致问题都是内存限制。
	2、 主从复制机制的原理概述是怎样的？常见的存在形式有哪些？
		1.主库接收用户做crud操作，写入数据库，更新结果集到binlog中
		2.主从同步是主找从的，从库IO发起请求，主库的主进程看从库 master change中给的参数是否合法，如果合法主进程交给IO进程执行 3 操作，否则拒绝处理
		3.主库根据master的位置点，从这个位置点的binlog日志一直到binlog日志最后，将其准备发送给从库。
		4.将找到的binlog日志发送个i从库，并且还会发送新的日志点。
		5.从库接收到binlog日志，将其写入realy-log（中继日志）中。
		6.从库IO进程再向master info保存主库传过来的最后的binlog日志的日志位置点。
		7.从库IO时循环发起请求的，发了再要，不会管SQL读取中继日志的操作。从库IO根据新的日志点，向主库发起请求，主库执行 3 4 操作，再发送新的binlog给从库，从库再执行5操作。
		8.其实第一次向relay-log中放数据时候，SQL进程就已经知道，SQL进程将relay-log中的SQL语句转换成数据，写入从库，从而实现同步。
		9.从库SQL线程读取中计日志，并不会一次性读完，会把读取到的日志点存放到relay-log.info中
		常见形式：
			一主一从
			一主多从
			多主一从
			主主复制
	3、 分库分表中解释一下垂直和水平2种不同的拆分？
		垂直拆分：
			指按照业务对数据中的表进行拆分，同组的放到一个数据库上。
		水平拆分：
			相对于垂直拆分，水平拆分并不是将表做拆分，而是按照某个字段的某种规则来做拆分，拆分成若干个小表
			比如用户表的id，前10000数据放在user1库中，10000-30000放到user2表中。
	4、 分库分表中垂直分库方案会带来哪些问题？
		单表的数据量还是很大
		提高了整个应用的复杂度，形成了跨库事务
		引发“木桶效应”，任何一个短板可能影响整个系统
		部分表关系不能join只能通过服务相互调用来维系。甚至由于网络问题引发数据不一致问题。
	5、分布式数据存储中间件如mycat的核心流程是什么？
		拦截sql解析->数据源分配->请求响应->结果整合
		当Mycat收到一个sql时，首先会解析这个sql，查找涉及到的表，然后看此表的定义，如果由分片规则，则获取到sql里分片字段的值，并匹配分片函数，
		得到该sql对应的分片列表，然后将sql发往到这些分片去执行，最后手机和处理所有分片返回的结果数据，并输出到客户端。
	6、 概述一下mycat？
		MyCat背后时阿里曾经开源的知名产品。
		它是一个开源的分布式数据库系统，是一个实现了MySQL协议的Server，前端用户可以把他看作是一个数据库的代理，可以用mysql客户端去访问，
		其后端可以用mysql远程协议与多个myslq服务器通信，也可以用jdbc协议与大多数主流数据库服务器通信，其核心功能是分库分表，及一个大表水平拆分出很多小的表，一个很大的数据库垂直拆分表拆分成多个数据库。
	7、 解释一下全局表，ER表，分片表？
		全局表：一个字典类数据的表，每个表都可能用到，在各个数据节点上都会由冗余。
		分片表：按照一定规则后，表按照设置的primaryKey来分配到不同的数据节点上
		ER表：和分片表由外键关系的表，也是通过设置的primaryKey即与分片表的外键，和分片表按照一样的规则分配到不同的数据节点上。
	8、 Mycat的在分库分表之后，它是怎么支持联表查询的？
		使用好ER表
		善用全局表
		再sql上添加注解 /*!mycat:catlet=io.mycat.catlets.Sharejoin  */
	9、 进行库表拆分时，拆分规则怎么取舍？
		https://www.cnblogs.com/bjxq-cs88/p/9470405.html
		固定数量的离散分片规则：如果热度非常高，增长规模可以预计，增长量未定（扩容挺麻烦的，规划的时候最好提前规划）
		连续分片：历史数据，热度要求不高。优势：可以定时清理或者迁移数据（迁移扩容都好做）
	10、 Mycat中全局ID方案有哪些？程序自定义全局ID的方案有哪些？
		本地方式 sequenceHandlerType=0 配置sequence_confproperties 使用next vlaue for MYCATSEQ_XXX
		数据库方式 sequenceHandlerType = 1 配置sequence_db_conf.properties 使用next vlaue for MYCATSEQ_XXX或者指定autoincrement
		本地时间戳方式：id = 64位二进制(42毫秒+5机器id+5业务编码+12重复累加） sequenceHandlerType=2 配置sequence_time_conf.properties指定autoincrementment
		程序方式：Snowflake  UUID Redis
	11、 简述一下一致性hash的原理？这样设计的好处是什么？
		做数据迁移时候，不像离散分片那样，全部数据都会动，一致性hash的话，就只需要动一小部分数据。
	12、 4层负载和7层负载谁性能更高？为什么？这2者区别是什么？
		指的是OSI网络模型。4层是传输层，7层为应用层。
		七层负载均衡基本都是基本http协议的，适用于web服务器负载均衡。
		四层负载均衡组要是基于tcp协议报文的，可以做任何基于tcp/ip协议的软件的负载均衡。
		
		7层因共用负载使得整个网络更为智能化。层层把关
		4层负载均衡主要较为灵活，可以作为多种软件的负载均衡。吞吐量会更高。
	13、 讲一讲高可用方案
		官方建议使用HAProxy+Mycat集群+MySQL主从组成的高可用方案。
		如果还担心HAProxy的稳定性和单点问题，则可以用keepalived 的vip的浮动功能加以强化。